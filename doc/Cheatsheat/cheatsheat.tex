\documentclass[a4paper,landscape,8pt]{article}
\usepackage[landscape]{geometry}
\usepackage[utf8]{inputenc}

%opening
\title{Switching over to SimpleCV.}
\author{Copyright \copyright 2012 SimpleCV.\\}

\begin{document}

\maketitle

SimpleCV\footnote{References : O'Reilly Publication, Practical Computer Vision with SimpleCV by Nathan Oostendorp, Anthony Oliver, and Katherine Scott.}, which stands for Simple Computer Vision, is an easy-to-use Python frame-work that bundles together open source computer vision libraries and algorithms for solving problems. The idea of this document is to provide a quick reference for switching from Matlab and OpenCV to SimpleCV. 
\begin{flushleft}
\begin{tabular}{llll}
  \hline
  Description & Matlab & OpenCV & SimpleCV \\ \hline \\[.1cm] 
  Reading an image & imread('lenna.png')  & cvLoadImage('lenna.png') & Image('lenna.png')\\ [0.3cm]
  Converting the image \\ to RGB colorspace & filllllllllllllllllllllllll & CvtColor(bitmap, retVal, CV\_BGR2RGB) & img.toRGB() \\ [0.4cm]
  Converting the image \\ to BGR colorspace & fill & CvtColor(bitmap, retVal, CV\_RGB2BGR) & img.toBGR()\\ [0.4cm] 
  Converting the image \\ to HLS colorspace & fill & CvtColor(bitmap, retVal, CV\_RGB2HLS) & img.toHLS()\\ [0.4cm]
  Converting the image \\ to HSV colorspace & fill & CvtColor(bitmap, retVal, CV\_RGB2HSV) & img.toHSV()\\ [0.4cm]
  Converting the image \\ to XYZ colorspace & fill & CvtColor(bitmap, retVal, CV\_RGB2XYZ) & img.toXYZ()\\ [0.4cm] 
  \end{tabular}
\begin{tabular}{llll}
  \hline
  Description & Matlab & OpenCV & SimpleCV \\ \hline \\[.1cm] 
  
  Converting the image \\ to GRAY colorspace & fill & CvtColor(bitmap, retVal, CV\_RGB2GRAY) & img.toGray()\\ [0.6cm]
  
  Create a new, empty \\ OpenCV bitmap & fill & SetZero(bitmap) & img.getEmpty(channels)\\ [0.8cm]
  
  Full copy of the image &  fill & Copy(bitmap, newimg) & img.copy()\\ [.4cm]
  
  Resize the image & filllllllllllllllllllllllll& Resize(bitmap, scaled\_bitmap) & img.resize(x,y) \\ [.4cm]
  
  Smooth the image & & Smooth(r, ro, algorithm, win\_x, win\_y, &img.smooth(algorithm\_name, aperature,\\
  & & sigma, spatial\_sigma) &sigma, spatial\_sigma, grayscale) \\[.4cm]
  
  Invert image & & & img.invert() \\[.3cm]
  
  Horizontally mirror \\ an image & &Flip(bitmap, newimg\_bitmap, 1) & img.flipHorizontal() \\[.3cm]
  
  Vertically mirror \\ an image & &Flip(bitmap, newimg\_bitmap, 0) & img.flipVertical() \\[.3cm] 
  
  Stretch filter on  & & Threshold(grayscale\_bitmap, \\
  a greyscale image& & newimg, thresh\_low, 255,CV\_THRESH\_TOZERO) &img.stretch(thresh\_low, thresh\_high) \\[0.3cm]
  
  Binary threshold & & Threshold(bitmap, bitmap,\\
  of the image& & thresh, maxv, CV\_THRESH\_BINARY\_INV) &img.binarize(thresh, maxv, blocksize, p)\\[.3cm]
  
  Mean color of the image& & cv.Avg(bitmap)[0:3] & img.meanColor()\\[0.3cm]
  
  Finds the FeatureSet  & & GoodFeaturesToTrack(GrayscaleBitmap, eig\_image, &img.findCorners(maxnum, minquality,\\ 
  strongest corners first & & temp\_image, maxnum, minquality, mindistance, None) &mindistance)\\[.4cm]
  
  Blobs are continuous & & &img.findBlobs(threshval, minsize, \\
  light regions& & &maxsize, threshblocksize, threshconstant) \\[0.3cm]
  
  Finding the location& & HaarDetectObjects(EqualizedGrayscaleBitmap(),  &findHaarFeatures(self, cascade, scale\_factor,\\
  of a known object& & cascade.getCascade(), storage, scale\_factor, use\_canny) &  min\_neighbors, use\_canny) \\[0.3cm]
 
  Uploading the Image & & & \\
  to Imgur or Flickr & & & img.upload(dest,api\_key,api\_secret,verbose) \\[0.3cm]   

 \hline
\end{tabular}
\begin{tabular}{llll}
  \hline
  Description & Matlab & OpenCV & SimpleCV \\ \hline \\[.1cm] 
  Draw a circle \\ on the Image & & & img.drawCircle(ctr, rad, color, thickness)\\ [0.3cm]
  Draw a line & & & img.drawLine(pt1, pt2, color, thickness) \\[0.3cm]
  Size of image & & GetSize(bitmap)&img.size()\\[0.3cm]
  Split the image into a & & & img.split(cols, rows)\\
  series of image chunks \\[0.3cm]
  Split the channels & & Split(bitmap, b, g, r, None) &img.splitChannels(grayscale) \\
  of an image into RGB \\[0.3cm]
  Images of R,G,B channels \\
  are recombined into a & &Merge(b,g,r,None,retVal) & img.mergeChannels(r,b,g) \\
  single image\\[0.3cm]
  Apply a color correction\\
  curve in HSL space& & &img.applyHLSCurve(hCurve, lCurve, sCurve)\\[0.3cm]
  Apply a color correction\\ 
  curve in RGB space& & &img.applyRGBCurve(rCurve, gCurve, bCurve)\\[0.3cm]
  Applies Intensity to \\
  all three color channels & & & img.applyIntensityCurve(curve)\\[0.3cm]
  Returns image representing \\
  the distance of each pixel & & &img.colorDistance(color) \\ 
  from a given color tuple \\ [0.3cm]
  Apply morphological\\ 
  erosion to a image& & Erode(bitmap, retVal, kern, iterations) &img.erode(iterations) \\[0.3cm]
  Apply morphological\\ 
  dilation to a image& &Dilate(bitmap, retVal, kern, iterations) & img.dilate(iterations) \\[0.3cm]
\end{tabular}

\begin{tabular}{llll}
  \hline
  Description & Matlab & OpenCV & SimpleCV \\ \hline \\[.1cm] 
  Histogram equalization & & cv.EqualizeHist(GrayscaleBitmap, & img.equalize() \\
  on the image& &  Equalizedgraybitmap )  \\[0.3cm]
  Returns Image of\\ the string& &  &img.toString() \\[0.3cm]
  Applies erosion operation & & MorphologyEx(bitmap, retVal, & img.morphOpen()\\
  followed by a &  &  temp, kern, CV\_MOP\_OPEN, 1)  \\
  morphological dilation \\ [0.3cm]
  The difference between the\\
  morphological dilation and& & MorphologyEx(Bitmap, retVal, & img.morphGradient() \\
  the morphological gradient & & temp, kern, CV\_MOP\_GRADIENT, 1) \\[0.3cm]
  1D histogram(numpy array) \\ 
  of intensity for pixels & & &img.histogram(numbins)\\
  in the image \\[0.3cm]
  The histogram of the hue \\
  channel for the image& & &img.hueHistogram(bins)\\[0.3cm]
  Returns the peak hue \\
  values histogram of hues& & &img.huePeaks(bins)\\[0.3cm]
  
  Add two images& &Add(imgBitmap, otherBitmap, newBitmap) &img.\_\_add\_\_(other) \\[0.3cm]
  
  Subtract two images& &Sub(imgBitmap, otherBitmap, newBitmap) &img.\_\_sub\_\_(other)\\[0.3cm]
  
  Or two images& &Or(imgBitmap, otherBitmap, newBitmap) &img.\_\_or\_\_(other)\\[0.3cm]
  
  Image division operation\\
  taking two images as input & &Div(imgBitmap, otherBitmap, newBitmap) &img.\_\_div\_\_(other)\\[0.3cm]
  
  Raises every array element\\
  in image array to a power& & Pow(imgBitmap, otherBitmap, other) & img.\_\_pow\_\_(other)\\[0.3cm]
  
  \end{tabular}

\begin{tabular}{llll}
  \hline
  Description & Matlab & OpenCV & SimpleCV \\ \hline \\[.1cm] 
  
 Finds 2d and 1d \\
 barcodes in the image & & & img.findBarcode(zxing\_path)\\[0.3cm]

 Finds line segments  & & HoughLines2(em, CreateMemStorage(),  &img.findLines(threshold, minlinelength, \\
 in the image & & CV\_HOUGH\_PROBABILISTIC, 1.0, CV\_PI/180.0, &maxlinegap, cannyth1, cannyth2)\\
 & & threshold, minlinelength, maxlinegap)\\[0.3cm]
 
 Finds a chessboard & & FindChessboardCorners(EqualizedGrayscaleBitmap, & img.findChessboard(dimensions, subpixel)\\
 within that image & & dimensions, CV\_CALIB\_CB\_ADAPTIVE\_THRESH \\
 & & + CV\_CALIB\_CB\_NORMALIZE\_IMAGE )\\[0.3cm]
 
 Canny edge detection method& &Canny(GrayscaleBitmap, edgeMap, t1, t2) & img.edges(t1, t2)\\[0.3cm]
 
 function rotates an image \\
 around a specific point & & GetRotationMatrix2D(point , angle, & img.rotate(angle, fixed, point, scale)\\ 
 by the given angle & & scale, rotMat)\\ [0.3cm]
 
 return a shear-ed image\\ 
 from the cornerpoints& & GetAffineTransform(src, cornerpoints, aWarp) &img.shear(cornerpoints) \\[0.3cm]
 
 Function for warp \\
 performs an affine rotation & & cv.WarpPerspective(imgBitmap, retVal, rotMatrix) & img.transformPerspective(rotMatrix) \\[0.3cm]
  
 Returns the RGB value for\\
 a particular image pixel & & Get2D(Bitmap, y, x) &img.getPixel(x, y)\\[0.3cm] 
 
 Returns the gray value for \\ 
 a particular image pixel & & Get2D(GrayscaleBitmap(), y, x) & img.getGrayPixel( x, y) \\[0.3cm]
 Returns a single column of \\
 RGB values from the image& & GetCol(imgBitmap, column) & img.getVertScanline(column) \\[0.3cm]
 Returns a single row of \\
 RGB values from the image& & GetRow(imgBitmap, row) & img.getHorzScanline(row)\\[0.3cm]
 \end{tabular}

\begin{tabular}{llll}
  \hline
  Description & Matlab & OpenCV & SimpleCV \\ \hline \\[.1cm] 

 Returns a single column of \\
 gray values from the image& & GetCol(imgGrayscaleBitmap, column) & getVertScanlineGray(column)\\[0.3cm]
 
 Returns a single row of \\
 gray values from the image& & GetRow(imgGrayscaleBitmap, row) & getHorzScanlineGray(row)\\[0.3cm]
 
 Crops the image \\ 
 based on parameters& & & img.crop(x , y, w, h, centered)\\[0.3cm]
 
 Returns the selected region.&&&img.regionSelect(x1, y1, x2, y2 )\\[0.3cm]
 
 Clears out the entire image & & SetZero(Bitmap) & img.clear()\\[0.3cm]
 
 Draws the string on the image \\
 at the specified coordinates.&&&img.drawText(text , x , y , color, fontsize)\\[0.3cm]
 
 Draw a rectangle on the image & & & img.drawRectangle(x,y,w,h,color,width,alpha)\\[0.3cm]
 
 Shows the current image& & ShowImage("Image", image)& img.show(type)\\[0.3cm]
 
 Push a new drawing layer onto\\
 the back of the layer stack& & & img.addDrawingLayer(layer)\\[0.3cm]
 Insert a new layer into the \\
 layer stack at the specified index & & & img.insertDrawingLayer(layer, index)\\[0.3cm]
 Remove a layer from the layer \\
 stack based on the layer's index& & &img.removeDrawingLayer(index)\\[0.3cm]
 Return a drawing layer\\ 
 based on the index& & & img.getDrawingLayer(index)\\[0.3cm]
 Remove all of the drawing layers& & &img.clearLayers()\\[0.3cm]
 Return the array of \\
 DrawingLayer objects & & & img.layers()\\[0.3cm]
 Return all DrawingLayer \\
 objects as a single &&&img.mergedLayers()\\
 DrawingLayer.\\[0.3cm]
 & & & img.applyLayers(indicies)\\[0.3cm]
 \end{tabular}

\end{flushleft}
\end{document}
